<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Ball Bounce</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        #canvas-container {
            position: relative;
        }
        
        canvas {
            background-color: #1a1a1a;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        button {
            margin: 0 5px;
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
        <div id="info-panel">Shape: Triangle<br>Vertices touched: 0/3</div>
        <div id="controls">
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset</button>
            <button id="speedUpBtn">Speed Up</button>
            <button id="slowDownBtn">Slow Down</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const infoPanel = document.getElementById('info-panel');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedUpBtn = document.getElementById('speedUpBtn');
        const slowDownBtn = document.getElementById('slowDownBtn');
        
        // Set canvas size to window size
        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.8;
            canvas.height = window.innerHeight * 0.8;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Animation parameters
        let isPaused = false;
        let animationSpeed = 1.0;
        let currentSides = 3; // Start with triangle
        let vertices = [];
        let ball = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            radius: 8,
            glowIntensity: 0,
            maxGlow: 15,
            glowSpeed: 0.1
        };
        
        let touchedVertices = 0;
        let targetVertex = 0;
        let nextTargetVertex = 1;
        let isCompleteCycle = false;
        let lastTime = 0;
        
        // Initialize the polygon and ball
        function initPolygon() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.7;
            
            // Generate vertices for the current polygon
            vertices = [];
            for (let i = 0; i < currentSides; i++) {
                const angle = (i * 2 * Math.PI) / currentSides - Math.PI / 2;
                vertices.push({
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            }
            
            // Place ball at the center of the first side
            const firstSideMidpoint = {
                x: (vertices[0].x + vertices[1].x) / 2,
                y: (vertices[0].y + vertices[1].y) / 2
            };
            
            // Set initial velocity toward the next vertex
            const dx = vertices[1].x - firstSideMidpoint.x;
            const dy = vertices[1].y - firstSideMidpoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            ball.x = firstSideMidpoint.x;
            ball.y = firstSideMidpoint.y;
            ball.vx = (dx / distance) * 3 * animationSpeed;
            ball.vy = (dy / distance) * 3 * animationSpeed;
            
            // Reset tracking variables
            touchedVertices = 0;
            targetVertex = 0;
            nextTargetVertex = 1;
            isCompleteCycle = false;
            
            // Update info panel
            updateInfoPanel();
        }
        
        // Update info panel text
        function updateInfoPanel() {
            infoPanel.innerHTML = `Shape: ${getShapeName()}<br>Vertices touched: ${touchedVertices}/${currentSides}`;
        }
        
        // Get shape name based on number of sides
        function getShapeName() {
            const names = ["Triangle", "Square", "Pentagon", "Hexagon", "Heptagon", "Octagon", "Nonagon", "Decagon"];
            return names[currentSides - 3] || `${currentSides}-gon`;
        }
        
        // Check if point is inside polygon using ray casting algorithm
        function isPointInsidePolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > y) !== (polygon[j].y > y)) &&
                    (x < (polygon[j].x - polygon[i].x) * (y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        // Calculate distance from point to line segment
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return { distance: Math.sqrt(dx * dx + dy * dy), closestX: xx, closestY: yy };
        }
        
        // Handle collision with polygon edges
        function handleCollision() {
            const edgeDistance = 5; // Minimum distance before collision is detected
            
            for (let i = 0; i < currentSides; i++) {
                const nextIndex = (i + 1) % currentSides;
                const p1 = vertices[i];
                const p2 = vertices[nextIndex];
                
                const result = distanceToLineSegment(ball.x, ball.y, p1.x, p1.y, p2.x, p2.y);
                
                if (result.distance < ball.radius + edgeDistance) {
                    // Calculate normal vector of the edge
                    const edgeX = p2.x - p1.x;
                    const edgeY = p2.y - p1.y;
                    const normalX = -edgeY;
                    const normalY = edgeX;
                    
                    // Normalize the normal
                    const length = Math.sqrt(normalX * normalX + normalY * normalY);
                    const normalizedNormalX = normalX / length;
                    const normalizedNormalY = normalY / length;
                    
                    // Make sure normal points inward
                    const center = {
                        x: canvas.width / 2,
                        y: canvas.height / 2
                    };
                    
                    const toCenterX = center.x - result.closestX;
                    const toCenterY = center.y - result.closestY;
                    const dotProduct = normalizedNormalX * toCenterX + normalizedNormalY * toCenterY;
                    
                    if (dotProduct < 0) {
                        normalizedNormalX *= -1;
                        normalizedNormalY *= -1;
                    }
                    
                    // Move ball outside the edge
                    const overlap = ball.radius + edgeDistance - result.distance;
                    ball.x += normalizedNormalX * overlap;
                    ball.y += normalizedNormalY * overlap;
                    
                    // Reflect velocity
                    const dotProductVelocity = ball.vx * normalizedNormalX + ball.vy * normalizedNormalY;
                    ball.vx -= 2 * dotProductVelocity * normalizedNormalX;
                    ball.vy -= 2 * dotProductVelocity * normalizedNormalY;
                    
                    // Check if we've reached the target vertex
                    const distToTarget = Math.sqrt(
                        Math.pow(ball.x - vertices[nextTargetVertex].x, 2) + 
                        Math.pow(ball.y - vertices[nextTargetVertex].y, 2)
                    );
                    
                    // If we're close enough to the target vertex, register it as touched
                    if (distToTarget < 15 && !isCompleteCycle) {
                        touchedVertices++;
                        
                        // Move to next target vertex in sequence
                        targetVertex = nextTargetVertex;
                        nextTargetVertex = (nextTargetVertex + 1) % currentSides;
                        
                        // Check if we completed a full cycle
                        if (touchedVertices === currentSides) {
                            isCompleteCycle = true;
                            
                            // Upgrade to next polygon after a short delay
                            setTimeout(() => {
                                if (currentSides < 10) { // Limit to decagon for performance
                                    currentSides++;
                                    initPolygon();
                                }
                            }, 1000);
                        }
                        
                        // Add visual feedback when touching a vertex
                        ball.glowIntensity = ball.maxGlow;
                    }
                    
                    break;
                }
            }
        }
        
        // Animation loop
        function animate(currentTime) {
            if (!isPaused) {
                // Calculate time delta
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                
                // Clear canvas with fade effect
                ctx.fillStyle = 'rgba(26, 26, 26, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw polygon
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < currentSides; i++) {
                    ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw glowing vertices
                ctx.shadowColor = '#4CAF50';
                ctx.shadowBlur = 15;
                for (let i = 0; i < currentSides; i++) {
                    ctx.fillStyle = i === targetVertex ? '#FFD700' : '#4CAF50';
                    ctx.beginPath();
                    ctx.arc(vertices[i].x, vertices[i].y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
                
                // Update ball position
                ball.x += ball.vx * animationSpeed;
                ball.y += ball.vy * animationSpeed;
                
                // Handle collisions
                handleCollision();
                
                // Update glow intensity
                if (ball.glowIntensity > 0) {
                    ball.glowIntensity -= ball.glowSpeed;
                    if (ball.glowIntensity < 0) ball.glowIntensity = 0;
                }
                
                // Draw ball with glow effect
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = ball.glowIntensity;
                ctx.fillStyle = '#FFFF00';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Draw ball core
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // Request next frame
                requestAnimationFrame(animate);
            } else {
                requestAnimationFrame(animate);
            }
        }
        
        // Event listeners
        pauseBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
        });
        
        resetBtn.addEventListener('click', () => {
            currentSides = 3;
            initPolygon();
        });
        
        speedUpBtn.addEventListener('click', () => {
            animationSpeed = Math.min(animationSpeed + 0.2, 3.0);
        });
        
        slowDownBtn.addEventListener('click', () => {
            animationSpeed = Math.max(animationSpeed - 0.2, 0.2);
        });
        
        // Initialize and start animation
        initPolygon();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
